type Address {
  street: String!
  street2: String
  postalcode: String!
  city: String!
  country: String!
}

input AddressCreateInput {
  street: String!
  street2: String
  postalcode: String!
  city: String!
  country: String!
}

input AddressCreateOneInput {
  create: AddressCreateInput
}

input AddressUpdateDataInput {
  street: String
  street2: String
  postalcode: String
  city: String
  country: String
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  street2: String
  street2_not: String
  street2_in: [String!]
  street2_not_in: [String!]
  street2_lt: String
  street2_lte: String
  street2_gt: String
  street2_gte: String
  street2_contains: String
  street2_not_contains: String
  street2_starts_with: String
  street2_not_starts_with: String
  street2_ends_with: String
  street2_not_ends_with: String
  postalcode: String
  postalcode_not: String
  postalcode_in: [String!]
  postalcode_not_in: [String!]
  postalcode_lt: String
  postalcode_lte: String
  postalcode_gt: String
  postalcode_gte: String
  postalcode_contains: String
  postalcode_not_contains: String
  postalcode_starts_with: String
  postalcode_not_starts_with: String
  postalcode_ends_with: String
  postalcode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  AND: [AddressWhereInput!]
}

type AggregateClient {
  count: Int!
}

type AggregateEstimate {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregateLegalForm {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  id: ID!
  user: User
  name: Name!
  legalForm: LegalForm!
  email: String
  phone: String
  address: Address
  company: String
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice!]
  estimates(where: EstimateWhereInput, orderBy: EstimateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Estimate!]
  createdAt: DateTime
  updatedAt: DateTime
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  id: ID
  user: UserCreateOneWithoutClientsInput
  name: NameCreateOneInput!
  legalForm: LegalFormCreateOneInput!
  email: String
  phone: String
  address: AddressCreateOneInput
  company: String
  invoices: InvoiceCreateManyWithoutClientInput
  estimates: EstimateCreateManyWithoutClientInput
}

input ClientCreateManyWithoutUserInput {
  create: [ClientCreateWithoutUserInput!]
  connect: [ClientWhereUniqueInput!]
}

input ClientCreateOneWithoutEstimatesInput {
  create: ClientCreateWithoutEstimatesInput
  connect: ClientWhereUniqueInput
}

input ClientCreateOneWithoutInvoicesInput {
  create: ClientCreateWithoutInvoicesInput
  connect: ClientWhereUniqueInput
}

input ClientCreateWithoutEstimatesInput {
  id: ID
  user: UserCreateOneWithoutClientsInput
  name: NameCreateOneInput!
  legalForm: LegalFormCreateOneInput!
  email: String
  phone: String
  address: AddressCreateOneInput
  company: String
  invoices: InvoiceCreateManyWithoutClientInput
}

input ClientCreateWithoutInvoicesInput {
  id: ID
  user: UserCreateOneWithoutClientsInput
  name: NameCreateOneInput!
  legalForm: LegalFormCreateOneInput!
  email: String
  phone: String
  address: AddressCreateOneInput
  company: String
  estimates: EstimateCreateManyWithoutClientInput
}

input ClientCreateWithoutUserInput {
  id: ID
  name: NameCreateOneInput!
  legalForm: LegalFormCreateOneInput!
  email: String
  phone: String
  address: AddressCreateOneInput
  company: String
  invoices: InvoiceCreateManyWithoutClientInput
  estimates: EstimateCreateManyWithoutClientInput
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  company_ASC
  company_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClientPreviousValues {
  id: ID!
  email: String
  phone: String
  company: String
  createdAt: DateTime
  updatedAt: DateTime
}

input ClientScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClientScalarWhereInput!]
  OR: [ClientScalarWhereInput!]
  NOT: [ClientScalarWhereInput!]
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  user: UserUpdateOneWithoutClientsInput
  name: NameUpdateOneRequiredInput
  legalForm: LegalFormUpdateOneRequiredInput
  email: String
  phone: String
  address: AddressUpdateOneInput
  company: String
  invoices: InvoiceUpdateManyWithoutClientInput
  estimates: EstimateUpdateManyWithoutClientInput
}

input ClientUpdateManyDataInput {
  email: String
  phone: String
  company: String
}

input ClientUpdateManyMutationInput {
  email: String
  phone: String
  company: String
}

input ClientUpdateManyWithoutUserInput {
  create: [ClientCreateWithoutUserInput!]
  delete: [ClientWhereUniqueInput!]
  connect: [ClientWhereUniqueInput!]
  set: [ClientWhereUniqueInput!]
  disconnect: [ClientWhereUniqueInput!]
  update: [ClientUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ClientUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ClientScalarWhereInput!]
  updateMany: [ClientUpdateManyWithWhereNestedInput!]
}

input ClientUpdateManyWithWhereNestedInput {
  where: ClientScalarWhereInput!
  data: ClientUpdateManyDataInput!
}

input ClientUpdateOneWithoutEstimatesInput {
  create: ClientCreateWithoutEstimatesInput
  update: ClientUpdateWithoutEstimatesDataInput
  upsert: ClientUpsertWithoutEstimatesInput
  delete: Boolean
  disconnect: Boolean
  connect: ClientWhereUniqueInput
}

input ClientUpdateOneWithoutInvoicesInput {
  create: ClientCreateWithoutInvoicesInput
  update: ClientUpdateWithoutInvoicesDataInput
  upsert: ClientUpsertWithoutInvoicesInput
  delete: Boolean
  disconnect: Boolean
  connect: ClientWhereUniqueInput
}

input ClientUpdateWithoutEstimatesDataInput {
  user: UserUpdateOneWithoutClientsInput
  name: NameUpdateOneRequiredInput
  legalForm: LegalFormUpdateOneRequiredInput
  email: String
  phone: String
  address: AddressUpdateOneInput
  company: String
  invoices: InvoiceUpdateManyWithoutClientInput
}

input ClientUpdateWithoutInvoicesDataInput {
  user: UserUpdateOneWithoutClientsInput
  name: NameUpdateOneRequiredInput
  legalForm: LegalFormUpdateOneRequiredInput
  email: String
  phone: String
  address: AddressUpdateOneInput
  company: String
  estimates: EstimateUpdateManyWithoutClientInput
}

input ClientUpdateWithoutUserDataInput {
  name: NameUpdateOneRequiredInput
  legalForm: LegalFormUpdateOneRequiredInput
  email: String
  phone: String
  address: AddressUpdateOneInput
  company: String
  invoices: InvoiceUpdateManyWithoutClientInput
  estimates: EstimateUpdateManyWithoutClientInput
}

input ClientUpdateWithWhereUniqueWithoutUserInput {
  where: ClientWhereUniqueInput!
  data: ClientUpdateWithoutUserDataInput!
}

input ClientUpsertWithoutEstimatesInput {
  update: ClientUpdateWithoutEstimatesDataInput!
  create: ClientCreateWithoutEstimatesInput!
}

input ClientUpsertWithoutInvoicesInput {
  update: ClientUpdateWithoutInvoicesDataInput!
  create: ClientCreateWithoutInvoicesInput!
}

input ClientUpsertWithWhereUniqueWithoutUserInput {
  where: ClientWhereUniqueInput!
  update: ClientUpdateWithoutUserDataInput!
  create: ClientCreateWithoutUserInput!
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  name: NameWhereInput
  legalForm: LegalFormWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: AddressWhereInput
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  invoices_some: InvoiceWhereInput
  estimates_some: EstimateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
}

scalar DateTime

type Estimate {
  id: ID!
  userId: ID!
  user: User
  client: Client
  staticUser: Json
  staticClient: Json
  state: State!
  estimateNumber: String
  startedDate: DateTime!
  deliveryDate: DateTime!
  validityDate: DateTime!
  message: String
  staticProducts: [ItemStatic!]
  products: [Item!]
  price: Float!
  footNote: String
  createdAt: DateTime
  updatedAt: DateTime
}

type EstimateConnection {
  pageInfo: PageInfo!
  edges: [EstimateEdge]!
  aggregate: AggregateEstimate!
}

input EstimateCreateInput {
  id: ID
  userId: ID!
  user: UserCreateOneWithoutEstimatesInput
  client: ClientCreateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State!
  estimateNumber: String
  startedDate: DateTime!
  deliveryDate: DateTime!
  validityDate: DateTime!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

input EstimateCreateManyWithoutClientInput {
  create: [EstimateCreateWithoutClientInput!]
  connect: [EstimateWhereUniqueInput!]
}

input EstimateCreateManyWithoutUserInput {
  create: [EstimateCreateWithoutUserInput!]
  connect: [EstimateWhereUniqueInput!]
}

input EstimateCreateWithoutClientInput {
  id: ID
  userId: ID!
  user: UserCreateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State!
  estimateNumber: String
  startedDate: DateTime!
  deliveryDate: DateTime!
  validityDate: DateTime!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

input EstimateCreateWithoutUserInput {
  id: ID
  userId: ID!
  client: ClientCreateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State!
  estimateNumber: String
  startedDate: DateTime!
  deliveryDate: DateTime!
  validityDate: DateTime!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

type EstimateEdge {
  node: Estimate!
  cursor: String!
}

enum EstimateOrderByInput {
  id_ASC
  id_DESC
  userId_ASC
  userId_DESC
  staticUser_ASC
  staticUser_DESC
  staticClient_ASC
  staticClient_DESC
  state_ASC
  state_DESC
  estimateNumber_ASC
  estimateNumber_DESC
  startedDate_ASC
  startedDate_DESC
  deliveryDate_ASC
  deliveryDate_DESC
  validityDate_ASC
  validityDate_DESC
  message_ASC
  message_DESC
  price_ASC
  price_DESC
  footNote_ASC
  footNote_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EstimatePreviousValues {
  id: ID!
  userId: ID!
  staticUser: Json
  staticClient: Json
  state: State!
  estimateNumber: String
  startedDate: DateTime!
  deliveryDate: DateTime!
  validityDate: DateTime!
  message: String
  price: Float!
  footNote: String
  createdAt: DateTime
  updatedAt: DateTime
}

input EstimateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  state: State
  state_not: State
  state_in: [State!]
  state_not_in: [State!]
  estimateNumber: String
  estimateNumber_not: String
  estimateNumber_in: [String!]
  estimateNumber_not_in: [String!]
  estimateNumber_lt: String
  estimateNumber_lte: String
  estimateNumber_gt: String
  estimateNumber_gte: String
  estimateNumber_contains: String
  estimateNumber_not_contains: String
  estimateNumber_starts_with: String
  estimateNumber_not_starts_with: String
  estimateNumber_ends_with: String
  estimateNumber_not_ends_with: String
  startedDate: DateTime
  startedDate_not: DateTime
  startedDate_in: [DateTime!]
  startedDate_not_in: [DateTime!]
  startedDate_lt: DateTime
  startedDate_lte: DateTime
  startedDate_gt: DateTime
  startedDate_gte: DateTime
  deliveryDate: DateTime
  deliveryDate_not: DateTime
  deliveryDate_in: [DateTime!]
  deliveryDate_not_in: [DateTime!]
  deliveryDate_lt: DateTime
  deliveryDate_lte: DateTime
  deliveryDate_gt: DateTime
  deliveryDate_gte: DateTime
  validityDate: DateTime
  validityDate_not: DateTime
  validityDate_in: [DateTime!]
  validityDate_not_in: [DateTime!]
  validityDate_lt: DateTime
  validityDate_lte: DateTime
  validityDate_gt: DateTime
  validityDate_gte: DateTime
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  footNote: String
  footNote_not: String
  footNote_in: [String!]
  footNote_not_in: [String!]
  footNote_lt: String
  footNote_lte: String
  footNote_gt: String
  footNote_gte: String
  footNote_contains: String
  footNote_not_contains: String
  footNote_starts_with: String
  footNote_not_starts_with: String
  footNote_ends_with: String
  footNote_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EstimateScalarWhereInput!]
  OR: [EstimateScalarWhereInput!]
  NOT: [EstimateScalarWhereInput!]
}

type EstimateSubscriptionPayload {
  mutation: MutationType!
  node: Estimate
  updatedFields: [String!]
  previousValues: EstimatePreviousValues
}

input EstimateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EstimateWhereInput
  AND: [EstimateSubscriptionWhereInput!]
}

input EstimateUpdateInput {
  userId: ID
  user: UserUpdateOneWithoutEstimatesInput
  client: ClientUpdateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State
  estimateNumber: String
  startedDate: DateTime
  deliveryDate: DateTime
  validityDate: DateTime
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input EstimateUpdateManyDataInput {
  userId: ID
  staticUser: Json
  staticClient: Json
  state: State
  estimateNumber: String
  startedDate: DateTime
  deliveryDate: DateTime
  validityDate: DateTime
  message: String
  price: Float
  footNote: String
}

input EstimateUpdateManyMutationInput {
  userId: ID
  staticUser: Json
  staticClient: Json
  state: State
  estimateNumber: String
  startedDate: DateTime
  deliveryDate: DateTime
  validityDate: DateTime
  message: String
  price: Float
  footNote: String
}

input EstimateUpdateManyWithoutClientInput {
  create: [EstimateCreateWithoutClientInput!]
  delete: [EstimateWhereUniqueInput!]
  connect: [EstimateWhereUniqueInput!]
  set: [EstimateWhereUniqueInput!]
  disconnect: [EstimateWhereUniqueInput!]
  update: [EstimateUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [EstimateUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [EstimateScalarWhereInput!]
  updateMany: [EstimateUpdateManyWithWhereNestedInput!]
}

input EstimateUpdateManyWithoutUserInput {
  create: [EstimateCreateWithoutUserInput!]
  delete: [EstimateWhereUniqueInput!]
  connect: [EstimateWhereUniqueInput!]
  set: [EstimateWhereUniqueInput!]
  disconnect: [EstimateWhereUniqueInput!]
  update: [EstimateUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [EstimateUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [EstimateScalarWhereInput!]
  updateMany: [EstimateUpdateManyWithWhereNestedInput!]
}

input EstimateUpdateManyWithWhereNestedInput {
  where: EstimateScalarWhereInput!
  data: EstimateUpdateManyDataInput!
}

input EstimateUpdateWithoutClientDataInput {
  userId: ID
  user: UserUpdateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State
  estimateNumber: String
  startedDate: DateTime
  deliveryDate: DateTime
  validityDate: DateTime
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input EstimateUpdateWithoutUserDataInput {
  userId: ID
  client: ClientUpdateOneWithoutEstimatesInput
  staticUser: Json
  staticClient: Json
  state: State
  estimateNumber: String
  startedDate: DateTime
  deliveryDate: DateTime
  validityDate: DateTime
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input EstimateUpdateWithWhereUniqueWithoutClientInput {
  where: EstimateWhereUniqueInput!
  data: EstimateUpdateWithoutClientDataInput!
}

input EstimateUpdateWithWhereUniqueWithoutUserInput {
  where: EstimateWhereUniqueInput!
  data: EstimateUpdateWithoutUserDataInput!
}

input EstimateUpsertWithWhereUniqueWithoutClientInput {
  where: EstimateWhereUniqueInput!
  update: EstimateUpdateWithoutClientDataInput!
  create: EstimateCreateWithoutClientInput!
}

input EstimateUpsertWithWhereUniqueWithoutUserInput {
  where: EstimateWhereUniqueInput!
  update: EstimateUpdateWithoutUserDataInput!
  create: EstimateCreateWithoutUserInput!
}

input EstimateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  user: UserWhereInput
  client: ClientWhereInput
  state: State
  state_not: State
  state_in: [State!]
  state_not_in: [State!]
  estimateNumber: String
  estimateNumber_not: String
  estimateNumber_in: [String!]
  estimateNumber_not_in: [String!]
  estimateNumber_lt: String
  estimateNumber_lte: String
  estimateNumber_gt: String
  estimateNumber_gte: String
  estimateNumber_contains: String
  estimateNumber_not_contains: String
  estimateNumber_starts_with: String
  estimateNumber_not_starts_with: String
  estimateNumber_ends_with: String
  estimateNumber_not_ends_with: String
  startedDate: DateTime
  startedDate_not: DateTime
  startedDate_in: [DateTime!]
  startedDate_not_in: [DateTime!]
  startedDate_lt: DateTime
  startedDate_lte: DateTime
  startedDate_gt: DateTime
  startedDate_gte: DateTime
  deliveryDate: DateTime
  deliveryDate_not: DateTime
  deliveryDate_in: [DateTime!]
  deliveryDate_not_in: [DateTime!]
  deliveryDate_lt: DateTime
  deliveryDate_lte: DateTime
  deliveryDate_gt: DateTime
  deliveryDate_gte: DateTime
  validityDate: DateTime
  validityDate_not: DateTime
  validityDate_in: [DateTime!]
  validityDate_not_in: [DateTime!]
  validityDate_lt: DateTime
  validityDate_lte: DateTime
  validityDate_gt: DateTime
  validityDate_gte: DateTime
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  staticProducts_some: ItemStaticWhereInput
  staticProducts_every: ItemStaticRestrictedWhereInput
  staticProducts_none: ItemStaticRestrictedWhereInput
  products_some: ItemWhereInput
  products_every: ItemRestrictedWhereInput
  products_none: ItemRestrictedWhereInput
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  footNote: String
  footNote_not: String
  footNote_in: [String!]
  footNote_not_in: [String!]
  footNote_lt: String
  footNote_lte: String
  footNote_gt: String
  footNote_gte: String
  footNote_contains: String
  footNote_not_contains: String
  footNote_starts_with: String
  footNote_not_starts_with: String
  footNote_ends_with: String
  footNote_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EstimateWhereInput!]
}

input EstimateWhereUniqueInput {
  id: ID
}

type Invoice {
  id: ID!
  userId: ID!
  user: User
  client: Client
  staticUser: Json
  staticClient: Json
  state: State!
  invoiceNumber: String
  billingDate: DateTime!
  paymentCondition: Float!
  deadline: DateTime!
  lateFee: Float!
  message: String
  staticProducts: [ItemStatic!]
  products: [Item!]
  price: Float!
  footNote: String
  createdAt: DateTime
  updatedAt: DateTime
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge]!
  aggregate: AggregateInvoice!
}

input InvoiceCreateInput {
  id: ID
  userId: ID!
  user: UserCreateOneWithoutInvoicesInput
  client: ClientCreateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State!
  invoiceNumber: String
  billingDate: DateTime!
  paymentCondition: Float!
  deadline: DateTime!
  lateFee: Float!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

input InvoiceCreateManyWithoutClientInput {
  create: [InvoiceCreateWithoutClientInput!]
  connect: [InvoiceWhereUniqueInput!]
}

input InvoiceCreateManyWithoutUserInput {
  create: [InvoiceCreateWithoutUserInput!]
  connect: [InvoiceWhereUniqueInput!]
}

input InvoiceCreateWithoutClientInput {
  id: ID
  userId: ID!
  user: UserCreateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State!
  invoiceNumber: String
  billingDate: DateTime!
  paymentCondition: Float!
  deadline: DateTime!
  lateFee: Float!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

input InvoiceCreateWithoutUserInput {
  id: ID
  userId: ID!
  client: ClientCreateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State!
  invoiceNumber: String
  billingDate: DateTime!
  paymentCondition: Float!
  deadline: DateTime!
  lateFee: Float!
  message: String
  staticProducts: ItemStaticCreateManyInput
  products: ItemCreateManyInput
  price: Float!
  footNote: String
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

enum InvoiceOrderByInput {
  id_ASC
  id_DESC
  userId_ASC
  userId_DESC
  staticUser_ASC
  staticUser_DESC
  staticClient_ASC
  staticClient_DESC
  state_ASC
  state_DESC
  invoiceNumber_ASC
  invoiceNumber_DESC
  billingDate_ASC
  billingDate_DESC
  paymentCondition_ASC
  paymentCondition_DESC
  deadline_ASC
  deadline_DESC
  lateFee_ASC
  lateFee_DESC
  message_ASC
  message_DESC
  price_ASC
  price_DESC
  footNote_ASC
  footNote_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InvoicePreviousValues {
  id: ID!
  userId: ID!
  staticUser: Json
  staticClient: Json
  state: State!
  invoiceNumber: String
  billingDate: DateTime!
  paymentCondition: Float!
  deadline: DateTime!
  lateFee: Float!
  message: String
  price: Float!
  footNote: String
  createdAt: DateTime
  updatedAt: DateTime
}

input InvoiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  state: State
  state_not: State
  state_in: [State!]
  state_not_in: [State!]
  invoiceNumber: String
  invoiceNumber_not: String
  invoiceNumber_in: [String!]
  invoiceNumber_not_in: [String!]
  invoiceNumber_lt: String
  invoiceNumber_lte: String
  invoiceNumber_gt: String
  invoiceNumber_gte: String
  invoiceNumber_contains: String
  invoiceNumber_not_contains: String
  invoiceNumber_starts_with: String
  invoiceNumber_not_starts_with: String
  invoiceNumber_ends_with: String
  invoiceNumber_not_ends_with: String
  billingDate: DateTime
  billingDate_not: DateTime
  billingDate_in: [DateTime!]
  billingDate_not_in: [DateTime!]
  billingDate_lt: DateTime
  billingDate_lte: DateTime
  billingDate_gt: DateTime
  billingDate_gte: DateTime
  paymentCondition: Float
  paymentCondition_not: Float
  paymentCondition_in: [Float!]
  paymentCondition_not_in: [Float!]
  paymentCondition_lt: Float
  paymentCondition_lte: Float
  paymentCondition_gt: Float
  paymentCondition_gte: Float
  deadline: DateTime
  deadline_not: DateTime
  deadline_in: [DateTime!]
  deadline_not_in: [DateTime!]
  deadline_lt: DateTime
  deadline_lte: DateTime
  deadline_gt: DateTime
  deadline_gte: DateTime
  lateFee: Float
  lateFee_not: Float
  lateFee_in: [Float!]
  lateFee_not_in: [Float!]
  lateFee_lt: Float
  lateFee_lte: Float
  lateFee_gt: Float
  lateFee_gte: Float
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  footNote: String
  footNote_not: String
  footNote_in: [String!]
  footNote_not_in: [String!]
  footNote_lt: String
  footNote_lte: String
  footNote_gt: String
  footNote_gte: String
  footNote_contains: String
  footNote_not_contains: String
  footNote_starts_with: String
  footNote_not_starts_with: String
  footNote_ends_with: String
  footNote_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceScalarWhereInput!]
  OR: [InvoiceScalarWhereInput!]
  NOT: [InvoiceScalarWhereInput!]
}

type InvoiceSubscriptionPayload {
  mutation: MutationType!
  node: Invoice
  updatedFields: [String!]
  previousValues: InvoicePreviousValues
}

input InvoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvoiceWhereInput
  AND: [InvoiceSubscriptionWhereInput!]
}

input InvoiceUpdateInput {
  userId: ID
  user: UserUpdateOneWithoutInvoicesInput
  client: ClientUpdateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State
  invoiceNumber: String
  billingDate: DateTime
  paymentCondition: Float
  deadline: DateTime
  lateFee: Float
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input InvoiceUpdateManyDataInput {
  userId: ID
  staticUser: Json
  staticClient: Json
  state: State
  invoiceNumber: String
  billingDate: DateTime
  paymentCondition: Float
  deadline: DateTime
  lateFee: Float
  message: String
  price: Float
  footNote: String
}

input InvoiceUpdateManyMutationInput {
  userId: ID
  staticUser: Json
  staticClient: Json
  state: State
  invoiceNumber: String
  billingDate: DateTime
  paymentCondition: Float
  deadline: DateTime
  lateFee: Float
  message: String
  price: Float
  footNote: String
}

input InvoiceUpdateManyWithoutClientInput {
  create: [InvoiceCreateWithoutClientInput!]
  delete: [InvoiceWhereUniqueInput!]
  connect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
}

input InvoiceUpdateManyWithoutUserInput {
  create: [InvoiceCreateWithoutUserInput!]
  delete: [InvoiceWhereUniqueInput!]
  connect: [InvoiceWhereUniqueInput!]
  set: [InvoiceWhereUniqueInput!]
  disconnect: [InvoiceWhereUniqueInput!]
  update: [InvoiceUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [InvoiceUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [InvoiceScalarWhereInput!]
  updateMany: [InvoiceUpdateManyWithWhereNestedInput!]
}

input InvoiceUpdateManyWithWhereNestedInput {
  where: InvoiceScalarWhereInput!
  data: InvoiceUpdateManyDataInput!
}

input InvoiceUpdateWithoutClientDataInput {
  userId: ID
  user: UserUpdateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State
  invoiceNumber: String
  billingDate: DateTime
  paymentCondition: Float
  deadline: DateTime
  lateFee: Float
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input InvoiceUpdateWithoutUserDataInput {
  userId: ID
  client: ClientUpdateOneWithoutInvoicesInput
  staticUser: Json
  staticClient: Json
  state: State
  invoiceNumber: String
  billingDate: DateTime
  paymentCondition: Float
  deadline: DateTime
  lateFee: Float
  message: String
  staticProducts: ItemStaticUpdateManyInput
  products: ItemUpdateManyInput
  price: Float
  footNote: String
}

input InvoiceUpdateWithWhereUniqueWithoutClientInput {
  where: InvoiceWhereUniqueInput!
  data: InvoiceUpdateWithoutClientDataInput!
}

input InvoiceUpdateWithWhereUniqueWithoutUserInput {
  where: InvoiceWhereUniqueInput!
  data: InvoiceUpdateWithoutUserDataInput!
}

input InvoiceUpsertWithWhereUniqueWithoutClientInput {
  where: InvoiceWhereUniqueInput!
  update: InvoiceUpdateWithoutClientDataInput!
  create: InvoiceCreateWithoutClientInput!
}

input InvoiceUpsertWithWhereUniqueWithoutUserInput {
  where: InvoiceWhereUniqueInput!
  update: InvoiceUpdateWithoutUserDataInput!
  create: InvoiceCreateWithoutUserInput!
}

input InvoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  user: UserWhereInput
  client: ClientWhereInput
  state: State
  state_not: State
  state_in: [State!]
  state_not_in: [State!]
  invoiceNumber: String
  invoiceNumber_not: String
  invoiceNumber_in: [String!]
  invoiceNumber_not_in: [String!]
  invoiceNumber_lt: String
  invoiceNumber_lte: String
  invoiceNumber_gt: String
  invoiceNumber_gte: String
  invoiceNumber_contains: String
  invoiceNumber_not_contains: String
  invoiceNumber_starts_with: String
  invoiceNumber_not_starts_with: String
  invoiceNumber_ends_with: String
  invoiceNumber_not_ends_with: String
  billingDate: DateTime
  billingDate_not: DateTime
  billingDate_in: [DateTime!]
  billingDate_not_in: [DateTime!]
  billingDate_lt: DateTime
  billingDate_lte: DateTime
  billingDate_gt: DateTime
  billingDate_gte: DateTime
  paymentCondition: Float
  paymentCondition_not: Float
  paymentCondition_in: [Float!]
  paymentCondition_not_in: [Float!]
  paymentCondition_lt: Float
  paymentCondition_lte: Float
  paymentCondition_gt: Float
  paymentCondition_gte: Float
  deadline: DateTime
  deadline_not: DateTime
  deadline_in: [DateTime!]
  deadline_not_in: [DateTime!]
  deadline_lt: DateTime
  deadline_lte: DateTime
  deadline_gt: DateTime
  deadline_gte: DateTime
  lateFee: Float
  lateFee_not: Float
  lateFee_in: [Float!]
  lateFee_not_in: [Float!]
  lateFee_lt: Float
  lateFee_lte: Float
  lateFee_gt: Float
  lateFee_gte: Float
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  staticProducts_some: ItemStaticWhereInput
  staticProducts_every: ItemStaticRestrictedWhereInput
  staticProducts_none: ItemStaticRestrictedWhereInput
  products_some: ItemWhereInput
  products_every: ItemRestrictedWhereInput
  products_none: ItemRestrictedWhereInput
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  footNote: String
  footNote_not: String
  footNote_in: [String!]
  footNote_not_in: [String!]
  footNote_lt: String
  footNote_lte: String
  footNote_gt: String
  footNote_gte: String
  footNote_contains: String
  footNote_not_contains: String
  footNote_starts_with: String
  footNote_not_starts_with: String
  footNote_ends_with: String
  footNote_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceWhereInput!]
}

input InvoiceWhereUniqueInput {
  id: ID
}

type Item {
  product: Product!
  quantity: Float!
}

input ItemCreateInput {
  product: ProductCreateOneInput!
  quantity: Float!
}

input ItemCreateManyInput {
  create: [ItemCreateInput!]
}

input ItemRestrictedWhereInput {
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemRestrictedWhereInput!]
}

input ItemScalarWhereInput {
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemStatic {
  product: Json!
  quantity: Float!
}

input ItemStaticCreateInput {
  product: Json!
  quantity: Float!
}

input ItemStaticCreateManyInput {
  create: [ItemStaticCreateInput!]
}

input ItemStaticRestrictedWhereInput {
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemStaticRestrictedWhereInput!]
}

input ItemStaticScalarWhereInput {
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemStaticScalarWhereInput!]
  OR: [ItemStaticScalarWhereInput!]
  NOT: [ItemStaticScalarWhereInput!]
}

input ItemStaticUpdateManyDataInput {
  product: Json
  quantity: Float
}

input ItemStaticUpdateManyInput {
  create: [ItemStaticCreateInput!]
  deleteMany: [ItemStaticScalarWhereInput!]
  updateMany: [ItemStaticUpdateManyWithWhereNestedInput!]
}

input ItemStaticUpdateManyWithWhereNestedInput {
  where: ItemStaticScalarWhereInput!
  data: ItemStaticUpdateManyDataInput!
}

input ItemStaticWhereInput {
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemStaticWhereInput!]
}

input ItemUpdateManyDataInput {
  quantity: Float
}

input ItemUpdateManyInput {
  create: [ItemCreateInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemWhereInput {
  product: ProductWhereInput
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  AND: [ItemWhereInput!]
}

scalar Json

type LegalForm {
  id: ID!
  form: String!
  title: String!
}

type LegalFormConnection {
  pageInfo: PageInfo!
  edges: [LegalFormEdge]!
  aggregate: AggregateLegalForm!
}

input LegalFormCreateInput {
  id: ID
  form: String!
  title: String!
}

input LegalFormCreateOneInput {
  create: LegalFormCreateInput
  connect: LegalFormWhereUniqueInput
}

type LegalFormEdge {
  node: LegalForm!
  cursor: String!
}

enum LegalFormOrderByInput {
  id_ASC
  id_DESC
  form_ASC
  form_DESC
  title_ASC
  title_DESC
}

type LegalFormPreviousValues {
  id: ID!
  form: String!
  title: String!
}

type LegalFormSubscriptionPayload {
  mutation: MutationType!
  node: LegalForm
  updatedFields: [String!]
  previousValues: LegalFormPreviousValues
}

input LegalFormSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LegalFormWhereInput
  AND: [LegalFormSubscriptionWhereInput!]
}

input LegalFormUpdateDataInput {
  form: String
  title: String
}

input LegalFormUpdateInput {
  form: String
  title: String
}

input LegalFormUpdateManyMutationInput {
  form: String
  title: String
}

input LegalFormUpdateOneRequiredInput {
  create: LegalFormCreateInput
  update: LegalFormUpdateDataInput
  upsert: LegalFormUpsertNestedInput
  connect: LegalFormWhereUniqueInput
}

input LegalFormUpsertNestedInput {
  update: LegalFormUpdateDataInput!
  create: LegalFormCreateInput!
}

input LegalFormWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  form: String
  form_not: String
  form_in: [String!]
  form_not_in: [String!]
  form_lt: String
  form_lte: String
  form_gt: String
  form_gte: String
  form_contains: String
  form_not_contains: String
  form_starts_with: String
  form_not_starts_with: String
  form_ends_with: String
  form_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [LegalFormWhereInput!]
}

input LegalFormWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createEstimate(data: EstimateCreateInput!): Estimate!
  updateEstimate(data: EstimateUpdateInput!, where: EstimateWhereUniqueInput!): Estimate
  updateManyEstimates(data: EstimateUpdateManyMutationInput!, where: EstimateWhereInput): BatchPayload!
  upsertEstimate(where: EstimateWhereUniqueInput!, create: EstimateCreateInput!, update: EstimateUpdateInput!): Estimate!
  deleteEstimate(where: EstimateWhereUniqueInput!): Estimate
  deleteManyEstimates(where: EstimateWhereInput): BatchPayload!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  upsertInvoice(where: InvoiceWhereUniqueInput!, create: InvoiceCreateInput!, update: InvoiceUpdateInput!): Invoice!
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  createLegalForm(data: LegalFormCreateInput!): LegalForm!
  updateLegalForm(data: LegalFormUpdateInput!, where: LegalFormWhereUniqueInput!): LegalForm
  updateManyLegalForms(data: LegalFormUpdateManyMutationInput!, where: LegalFormWhereInput): BatchPayload!
  upsertLegalForm(where: LegalFormWhereUniqueInput!, create: LegalFormCreateInput!, update: LegalFormUpdateInput!): LegalForm!
  deleteLegalForm(where: LegalFormWhereUniqueInput!): LegalForm
  deleteManyLegalForms(where: LegalFormWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Name {
  firstname: String!
  lastname: String!
}

input NameCreateInput {
  firstname: String!
  lastname: String!
}

input NameCreateOneInput {
  create: NameCreateInput
}

input NameUpdateDataInput {
  firstname: String
  lastname: String
}

input NameUpdateOneInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input NameUpdateOneRequiredInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
}

input NameUpsertNestedInput {
  update: NameUpdateDataInput!
  create: NameCreateInput!
}

input NameWhereInput {
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  AND: [NameWhereInput!]
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  user: User
  description: String!
  priceht: Float!
  vat: Float!
  pricettc: Float!
  unit: String
  createdAt: DateTime
  updatedAt: DateTime
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  user: UserCreateOneWithoutProductsInput
  description: String!
  priceht: Float!
  vat: Float!
  pricettc: Float!
  unit: String
}

input ProductCreateManyWithoutUserInput {
  create: [ProductCreateWithoutUserInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutUserInput {
  id: ID
  description: String!
  priceht: Float!
  vat: Float!
  pricettc: Float!
  unit: String
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  priceht_ASC
  priceht_DESC
  vat_ASC
  vat_DESC
  pricettc_ASC
  pricettc_DESC
  unit_ASC
  unit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  description: String!
  priceht: Float!
  vat: Float!
  pricettc: Float!
  unit: String
  createdAt: DateTime
  updatedAt: DateTime
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  priceht: Float
  priceht_not: Float
  priceht_in: [Float!]
  priceht_not_in: [Float!]
  priceht_lt: Float
  priceht_lte: Float
  priceht_gt: Float
  priceht_gte: Float
  vat: Float
  vat_not: Float
  vat_in: [Float!]
  vat_not_in: [Float!]
  vat_lt: Float
  vat_lte: Float
  vat_gt: Float
  vat_gte: Float
  pricettc: Float
  pricettc_not: Float
  pricettc_in: [Float!]
  pricettc_not_in: [Float!]
  pricettc_lt: Float
  pricettc_lte: Float
  pricettc_gt: Float
  pricettc_gte: Float
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  user: UserUpdateOneWithoutProductsInput
  description: String
  priceht: Float
  vat: Float
  pricettc: Float
  unit: String
}

input ProductUpdateManyDataInput {
  description: String
  priceht: Float
  vat: Float
  pricettc: Float
  unit: String
}

input ProductUpdateManyMutationInput {
  description: String
  priceht: Float
  vat: Float
  pricettc: Float
  unit: String
}

input ProductUpdateManyWithoutUserInput {
  create: [ProductCreateWithoutUserInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateWithoutUserDataInput {
  description: String
  priceht: Float
  vat: Float
  pricettc: Float
  unit: String
}

input ProductUpdateWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutUserDataInput!
}

input ProductUpsertWithWhereUniqueWithoutUserInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutUserDataInput!
  create: ProductCreateWithoutUserInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  priceht: Float
  priceht_not: Float
  priceht_in: [Float!]
  priceht_not_in: [Float!]
  priceht_lt: Float
  priceht_lte: Float
  priceht_gt: Float
  priceht_gte: Float
  vat: Float
  vat_not: Float
  vat_in: [Float!]
  vat_not_in: [Float!]
  vat_lt: Float
  vat_lte: Float
  vat_gt: Float
  vat_gte: Float
  pricettc: Float
  pricettc_not: Float
  pricettc_in: [Float!]
  pricettc_not_in: [Float!]
  pricettc_lt: Float
  pricettc_lte: Float
  pricettc_gt: Float
  pricettc_gte: Float
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  estimate(where: EstimateWhereUniqueInput!): Estimate
  estimates(where: EstimateWhereInput, orderBy: EstimateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Estimate]!
  estimatesConnection(where: EstimateWhereInput, orderBy: EstimateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EstimateConnection!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice]!
  invoicesConnection(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvoiceConnection!
  legalForm(where: LegalFormWhereUniqueInput!): LegalForm
  legalForms(where: LegalFormWhereInput, orderBy: LegalFormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LegalForm]!
  legalFormsConnection(where: LegalFormWhereInput, orderBy: LegalFormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LegalFormConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  USER
  ADMIN
}

enum State {
  DRAFT
  PENDING
  SEND
  DONE
}

enum Status {
  NOTACTIVE
  ACTIVE
}

type Subscription {
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  estimate(where: EstimateSubscriptionWhereInput): EstimateSubscriptionPayload
  invoice(where: InvoiceSubscriptionWhereInput): InvoiceSubscriptionPayload
  legalForm(where: LegalFormSubscriptionWhereInput): LegalFormSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: Name
  email: String!
  password: String
  address: Address
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client!]
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice!]
  estimates(where: EstimateWhereInput, orderBy: EstimateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Estimate!]
  createdAt: DateTime
  updatedAt: DateTime
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: NameCreateOneInput
  email: String!
  password: String
  address: AddressCreateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  products: ProductCreateManyWithoutUserInput
  clients: ClientCreateManyWithoutUserInput
  invoices: InvoiceCreateManyWithoutUserInput
  estimates: EstimateCreateManyWithoutUserInput
}

input UserCreateOneWithoutClientsInput {
  create: UserCreateWithoutClientsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutEstimatesInput {
  create: UserCreateWithoutEstimatesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInvoicesInput {
  create: UserCreateWithoutInvoicesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutProductsInput {
  create: UserCreateWithoutProductsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutClientsInput {
  id: ID
  name: NameCreateOneInput
  email: String!
  password: String
  address: AddressCreateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  products: ProductCreateManyWithoutUserInput
  invoices: InvoiceCreateManyWithoutUserInput
  estimates: EstimateCreateManyWithoutUserInput
}

input UserCreateWithoutEstimatesInput {
  id: ID
  name: NameCreateOneInput
  email: String!
  password: String
  address: AddressCreateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  products: ProductCreateManyWithoutUserInput
  clients: ClientCreateManyWithoutUserInput
  invoices: InvoiceCreateManyWithoutUserInput
}

input UserCreateWithoutInvoicesInput {
  id: ID
  name: NameCreateOneInput
  email: String!
  password: String
  address: AddressCreateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  products: ProductCreateManyWithoutUserInput
  clients: ClientCreateManyWithoutUserInput
  estimates: EstimateCreateManyWithoutUserInput
}

input UserCreateWithoutProductsInput {
  id: ID
  name: NameCreateOneInput
  email: String!
  password: String
  address: AddressCreateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  clients: ClientCreateManyWithoutUserInput
  invoices: InvoiceCreateManyWithoutUserInput
  estimates: EstimateCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  siret_ASC
  siret_DESC
  useVAT_ASC
  useVAT_DESC
  paymentInfo_ASC
  paymentInfo_DESC
  VATnumber_ASC
  VATnumber_DESC
  RCS_ASC
  RCS_DESC
  RM_ASC
  RM_DESC
  commercialName_ASC
  commercialName_DESC
  ape_ASC
  ape_DESC
  role_ASC
  role_DESC
  status_ASC
  status_DESC
  cgv_ASC
  cgv_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role!
  status: Status!
  cgv: String
  createdAt: DateTime
  updatedAt: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: NameUpdateOneInput
  email: String
  password: String
  address: AddressUpdateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
  products: ProductUpdateManyWithoutUserInput
  clients: ClientUpdateManyWithoutUserInput
  invoices: InvoiceUpdateManyWithoutUserInput
  estimates: EstimateUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
}

input UserUpdateOneWithoutClientsInput {
  create: UserCreateWithoutClientsInput
  update: UserUpdateWithoutClientsDataInput
  upsert: UserUpsertWithoutClientsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutEstimatesInput {
  create: UserCreateWithoutEstimatesInput
  update: UserUpdateWithoutEstimatesDataInput
  upsert: UserUpsertWithoutEstimatesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutInvoicesInput {
  create: UserCreateWithoutInvoicesInput
  update: UserUpdateWithoutInvoicesDataInput
  upsert: UserUpsertWithoutInvoicesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutProductsInput {
  create: UserCreateWithoutProductsInput
  update: UserUpdateWithoutProductsDataInput
  upsert: UserUpsertWithoutProductsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutClientsDataInput {
  name: NameUpdateOneInput
  email: String
  password: String
  address: AddressUpdateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
  products: ProductUpdateManyWithoutUserInput
  invoices: InvoiceUpdateManyWithoutUserInput
  estimates: EstimateUpdateManyWithoutUserInput
}

input UserUpdateWithoutEstimatesDataInput {
  name: NameUpdateOneInput
  email: String
  password: String
  address: AddressUpdateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
  products: ProductUpdateManyWithoutUserInput
  clients: ClientUpdateManyWithoutUserInput
  invoices: InvoiceUpdateManyWithoutUserInput
}

input UserUpdateWithoutInvoicesDataInput {
  name: NameUpdateOneInput
  email: String
  password: String
  address: AddressUpdateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
  products: ProductUpdateManyWithoutUserInput
  clients: ClientUpdateManyWithoutUserInput
  estimates: EstimateUpdateManyWithoutUserInput
}

input UserUpdateWithoutProductsDataInput {
  name: NameUpdateOneInput
  email: String
  password: String
  address: AddressUpdateOneInput
  phone: String
  siret: String
  useVAT: Boolean
  paymentInfo: String
  VATnumber: String
  RCS: String
  RM: String
  commercialName: String
  ape: String
  role: Role
  status: Status
  cgv: String
  clients: ClientUpdateManyWithoutUserInput
  invoices: InvoiceUpdateManyWithoutUserInput
  estimates: EstimateUpdateManyWithoutUserInput
}

input UserUpsertWithoutClientsInput {
  update: UserUpdateWithoutClientsDataInput!
  create: UserCreateWithoutClientsInput!
}

input UserUpsertWithoutEstimatesInput {
  update: UserUpdateWithoutEstimatesDataInput!
  create: UserCreateWithoutEstimatesInput!
}

input UserUpsertWithoutInvoicesInput {
  update: UserUpdateWithoutInvoicesDataInput!
  create: UserCreateWithoutInvoicesInput!
}

input UserUpsertWithoutProductsInput {
  update: UserUpdateWithoutProductsDataInput!
  create: UserCreateWithoutProductsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: NameWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  address: AddressWhereInput
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  siret: String
  siret_not: String
  siret_in: [String!]
  siret_not_in: [String!]
  siret_lt: String
  siret_lte: String
  siret_gt: String
  siret_gte: String
  siret_contains: String
  siret_not_contains: String
  siret_starts_with: String
  siret_not_starts_with: String
  siret_ends_with: String
  siret_not_ends_with: String
  useVAT: Boolean
  useVAT_not: Boolean
  paymentInfo: String
  paymentInfo_not: String
  paymentInfo_in: [String!]
  paymentInfo_not_in: [String!]
  paymentInfo_lt: String
  paymentInfo_lte: String
  paymentInfo_gt: String
  paymentInfo_gte: String
  paymentInfo_contains: String
  paymentInfo_not_contains: String
  paymentInfo_starts_with: String
  paymentInfo_not_starts_with: String
  paymentInfo_ends_with: String
  paymentInfo_not_ends_with: String
  VATnumber: String
  VATnumber_not: String
  VATnumber_in: [String!]
  VATnumber_not_in: [String!]
  VATnumber_lt: String
  VATnumber_lte: String
  VATnumber_gt: String
  VATnumber_gte: String
  VATnumber_contains: String
  VATnumber_not_contains: String
  VATnumber_starts_with: String
  VATnumber_not_starts_with: String
  VATnumber_ends_with: String
  VATnumber_not_ends_with: String
  RCS: String
  RCS_not: String
  RCS_in: [String!]
  RCS_not_in: [String!]
  RCS_lt: String
  RCS_lte: String
  RCS_gt: String
  RCS_gte: String
  RCS_contains: String
  RCS_not_contains: String
  RCS_starts_with: String
  RCS_not_starts_with: String
  RCS_ends_with: String
  RCS_not_ends_with: String
  RM: String
  RM_not: String
  RM_in: [String!]
  RM_not_in: [String!]
  RM_lt: String
  RM_lte: String
  RM_gt: String
  RM_gte: String
  RM_contains: String
  RM_not_contains: String
  RM_starts_with: String
  RM_not_starts_with: String
  RM_ends_with: String
  RM_not_ends_with: String
  commercialName: String
  commercialName_not: String
  commercialName_in: [String!]
  commercialName_not_in: [String!]
  commercialName_lt: String
  commercialName_lte: String
  commercialName_gt: String
  commercialName_gte: String
  commercialName_contains: String
  commercialName_not_contains: String
  commercialName_starts_with: String
  commercialName_not_starts_with: String
  commercialName_ends_with: String
  commercialName_not_ends_with: String
  ape: String
  ape_not: String
  ape_in: [String!]
  ape_not_in: [String!]
  ape_lt: String
  ape_lte: String
  ape_gt: String
  ape_gte: String
  ape_contains: String
  ape_not_contains: String
  ape_starts_with: String
  ape_not_starts_with: String
  ape_ends_with: String
  ape_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  cgv: String
  cgv_not: String
  cgv_in: [String!]
  cgv_not_in: [String!]
  cgv_lt: String
  cgv_lte: String
  cgv_gt: String
  cgv_gte: String
  cgv_contains: String
  cgv_not_contains: String
  cgv_starts_with: String
  cgv_not_starts_with: String
  cgv_ends_with: String
  cgv_not_ends_with: String
  products_some: ProductWhereInput
  clients_some: ClientWhereInput
  invoices_some: InvoiceWhereInput
  estimates_some: EstimateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
